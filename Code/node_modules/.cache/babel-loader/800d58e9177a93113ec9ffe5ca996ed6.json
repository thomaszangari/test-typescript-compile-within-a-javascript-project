{"ast":null,"code":"/**\n * Creates a model schema that (de)serializes from / to plain javascript objects.\n * Its factory method is: `() => ({})`\n *\n * @example\n * var todoSchema = createSimpleSchema({\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(todoSchema, { title: 'Test', done: false });\n * var todo = deserialize(todoSchema, json);\n *\n * @param {object} props property mapping,\n * @returns {object} model schema\n */\nfunction createSimpleSchema(props) {\n  return {\n    factory: function factory() {\n      return {};\n    },\n    props: props\n  };\n}\n\nvar formatters = {\n  j: function json(v) {\n    try {\n      return JSON.stringify(v);\n    } catch (error) {\n      return \"[UnexpectedJSONParseError]: \" + error.message;\n    }\n  }\n};\n\nfunction invariant(condition, message) {\n  if (!condition) {\n    var variables = Array.prototype.slice.call(arguments, 2);\n    var variablesToLog = [];\n    var index = 0;\n    var formattedMessage = message.replace(/%([a-zA-Z%])/g, function messageFormatter(match, format) {\n      if (match === \"%%\") return match;\n      var formatter = formatters[format];\n\n      if (typeof formatter === \"function\") {\n        var variable = variables[index++];\n        variablesToLog.push(variable);\n        return formatter(variable);\n      }\n\n      return match;\n    });\n\n    if (console && variablesToLog.length > 0) {\n      // eslint-disable-next-line no-console\n      console.log.apply(console, variablesToLog);\n    }\n\n    throw new Error(\"[serializr] \" + (formattedMessage || \"Illegal State\"));\n  }\n}\n\nfunction GUARDED_NOOP(err) {\n  if (err) // unguarded error...\n    throw new Error(err);\n}\n\nfunction once(fn) {\n  var fired = false;\n  return function () {\n    if (!fired) {\n      fired = true;\n      return fn.apply(null, arguments);\n    }\n\n    invariant(false, \"callback was invoked twice\");\n  };\n}\n\nfunction parallel(ar, processor, cb) {\n  // TODO: limit parallelization?\n  if (ar.length === 0) return void cb(null, []);\n  var left = ar.filter(function () {\n    return true;\n  }).length; // only count items processed by forEach\n\n  var resultArray = [];\n  var failed = false;\n\n  var processorCb = function processorCb(idx, err, result) {\n    if (err) {\n      if (!failed) {\n        failed = true;\n        cb(err);\n      }\n    } else {\n      resultArray[idx] = result;\n      if (--left === 0) cb(null, resultArray);\n    }\n  };\n\n  ar.forEach(function (value, idx) {\n    processor(value, processorCb.bind(null, idx), idx);\n  });\n}\n\nfunction isPrimitive(value) {\n  if (value === null) return true;\n  return typeof value !== \"object\" && typeof value !== \"function\";\n}\n\nfunction isModelSchema(thing) {\n  return thing && thing.factory && thing.props;\n}\n\nfunction isPropSchema(thing) {\n  return thing && thing.serializer && thing.deserializer;\n}\n\nfunction isAliasedPropSchema(propSchema) {\n  return typeof propSchema === \"object\" && !!propSchema.jsonname;\n}\n\nfunction isIdentifierPropSchema(propSchema) {\n  return typeof propSchema === \"object\" && propSchema.identifier === true;\n}\n\nfunction isAssignableTo(actualType, expectedType) {\n  while (actualType) {\n    if (actualType === expectedType) return true;\n    actualType = actualType.extends;\n  }\n\n  return false;\n}\n\nfunction isMapLike(thing) {\n  return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\";\n}\n\nfunction getIdentifierProp(modelSchema) {\n  invariant(isModelSchema(modelSchema)); // optimization: cache this lookup\n\n  while (modelSchema) {\n    for (var propName in modelSchema.props) {\n      if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true) return propName;\n    }\n\n    modelSchema = modelSchema.extends;\n  }\n\n  return null;\n}\n\nfunction processAdditionalPropArgs(propSchema, additionalArgs) {\n  if (additionalArgs) {\n    invariant(isPropSchema(propSchema), \"expected a propSchema\");\n    var argNames = [\"beforeDeserialize\", \"afterDeserialize\"];\n    argNames.forEach(function (argName) {\n      if (typeof additionalArgs[argName] === \"function\") {\n        propSchema[argName] = additionalArgs[argName];\n      }\n    });\n  }\n\n  return propSchema;\n}\n/**\n * Returns the standard model schema associated with a class / constructor function\n *\n * @param {object} thing\n * @returns {ModelSchema} model schema\n */\n\n\nfunction getDefaultModelSchema(thing) {\n  if (!thing) return null;\n  if (isModelSchema(thing)) return thing;\n  if (isModelSchema(thing.serializeInfo)) return thing.serializeInfo;\n  if (thing.constructor && thing.constructor.serializeInfo) return thing.constructor.serializeInfo;\n}\n/**\n * Sets the default model schema for class / constructor function.\n * Everywhere where a model schema is required as argument, this class / constructor function\n * can be passed in as well (for example when using `object` or `ref`.\n *\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n * as first argument anymore, because the default schema will be inferred from the instance type.\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {ModelSchema} modelSchema - a model schema\n * @returns {ModelSchema} model schema\n */\n\n\nfunction setDefaultModelSchema(clazz, modelSchema) {\n  invariant(isModelSchema(modelSchema));\n  return clazz.serializeInfo = modelSchema;\n}\n/**\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n *\n * @example\n * function Todo(title, done) {\n *     this.title = title;\n *     this.done = done;\n * }\n *\n * createModelSchema(Todo, {\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {object} props property mapping\n * @param {function} factory optional custom factory. Receives context as first arg\n * @returns {object} model schema\n */\n\n\nfunction createModelSchema(clazz, props, factory) {\n  invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\");\n  invariant(typeof clazz === \"function\", \"expected constructor function\");\n  var model = {\n    targetClass: clazz,\n    factory: factory || function () {\n      return new clazz();\n    },\n    props: props\n  }; // find super model\n\n  if (clazz.prototype.constructor !== Object) {\n    var s = getDefaultModelSchema(clazz.prototype.constructor);\n    if (s && s.targetClass !== clazz) model.extends = s;\n  }\n\n  setDefaultModelSchema(clazz, model);\n  return model;\n}\n/**\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: primitive(),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // outputs: { title : \"test\" }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\n\n\nfunction primitive(additionalArgs) {\n  var result = {\n    serializer: function serializer(value) {\n      invariant(isPrimitive(value), \"this value is not primitive: \" + value);\n      return value;\n    },\n    deserializer: function deserializer(jsonValue, done) {\n      if (!isPrimitive(jsonValue)) return void done(\"[serializr] this value is not primitive: \" + jsonValue);\n      return void done(null, jsonValue);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return _.SKIP\n *         },\n *         function(v) {\n *             return v;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\n */\n\n\nvar SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : {\n  SKIP: true\n};\n\nvar _defaultPrimitiveProp = primitive(); // Ugly way to get the parameter names since they aren't easily retrievable via reflection\n\n\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\nfunction getParamNames(func) {\n  var fnStr = func.toString().replace(STRIP_COMMENTS, \"\");\n  var result = fnStr.slice(fnStr.indexOf(\"(\") + 1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES);\n  if (result === null) result = [];\n  return result;\n}\n\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\n  invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\"); // Fix for @serializable used in class constructor params (typescript)\n\n  var factory;\n\n  if (propName === undefined && typeof target === \"function\" && target.prototype && descriptor !== undefined && typeof descriptor === \"number\") {\n    invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\");\n    invariant(propSchema.jsonname, \"Constructor params must use alias(name)\");\n    var paramNames = getParamNames(target);\n\n    if (paramNames.length >= descriptor) {\n      propName = paramNames[descriptor];\n      propSchema.paramNumber = descriptor;\n      descriptor = undefined;\n      target = target.prototype; // Create a factory so the constructor is called properly\n\n      factory = function factory(context) {\n        var params = [];\n\n        for (var i = 0; i < target.constructor.length; i++) {\n          Object.keys(context.modelSchema.props).forEach(function (key) {\n            var prop = context.modelSchema.props[key];\n\n            if (prop.paramNumber === i) {\n              params[i] = context.json[prop.jsonname];\n            }\n          });\n        }\n\n        return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))();\n      };\n    }\n  }\n\n  invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\");\n  var info = getDefaultModelSchema(target);\n  if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\")) info = createModelSchema(target.constructor, {}, factory);\n  if (info && info.targetClass !== target.constructor) // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n    info = createModelSchema(target.constructor, {}, factory);\n  info.props[propName] = propSchema; // MWE: why won't babel work without?\n\n  if (descriptor && !descriptor.get && !descriptor.set) descriptor.writable = true;\n  return descriptor;\n}\n/**\n * Decorator that defines a new property mapping on the default model schema for the class\n * it is used in.\n *\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n * The default factory will then invoke the constructor with the correct arguments as well.\n *\n * @example\n * class Todo {\n *     @serializable(primitive())\n *     title; // shorthand for primitves\n *\n *     @serializable done;\n *\n *     constructor(title, done) {\n *         this.title = title;\n *         this.done = done;\n *     }\n * }\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param arg1\n * @param arg2\n * @param arg3\n * @returns {PropertyDescriptor}\n */\n\n\nfunction serializable(arg1, arg2, arg3) {\n  if (arguments.length === 1) {\n    // decorated with propSchema\n    var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1;\n    invariant(isPropSchema(propSchema), \"@serializable expects prop schema\");\n    return serializableDecorator.bind(null, propSchema);\n  } else {\n    // decorated without arguments, treat as primitive\n    return serializableDecorator(primitive(), arg1, arg2, arg3);\n  }\n}\n/**\n * Serializes an object (graph) into json using the provided model schema.\n * The model schema can be omitted if the object type has a default model schema associated with it.\n * If a list of objects is provided, they should have an uniform type.\n *\n * @param arg1 class or modelschema to use. Optional\n * @param arg2 object(s) to serialize\n * @returns {object} serialized representation of the object\n */\n\n\nfunction serialize(arg1, arg2) {\n  invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\");\n  var thing = arguments.length === 1 ? arg1 : arg2;\n  var schema = arguments.length === 1 ? null : arg1;\n\n  if (Array.isArray(thing)) {\n    if (thing.length === 0) return []; // don't bother finding a schema\n    else if (!schema) schema = getDefaultModelSchema(thing[0]);else if (typeof schema !== \"object\") schema = getDefaultModelSchema(schema);\n  } else if (!schema) {\n    schema = getDefaultModelSchema(thing);\n  } else if (typeof schema !== \"object\") {\n    schema = getDefaultModelSchema(schema);\n  }\n\n  invariant(!!schema, \"Failed to find default schema for \" + arg1);\n  if (Array.isArray(thing)) return thing.map(function (item) {\n    return serializeWithSchema(schema, item);\n  });\n  return serializeWithSchema(schema, thing);\n}\n\nfunction checkStarSchemaInvariant(propDef) {\n  invariant(propDef === true || propDef.pattern, \"prop schema '*' can only be used with 'true' or a prop def with a 'pattern': \" + JSON.stringify(propDef));\n}\n\nfunction serializeWithSchema(schema, obj) {\n  invariant(schema && typeof schema === \"object\" && schema.props, \"Expected schema\");\n  invariant(obj && typeof obj === \"object\", \"Expected object\");\n  var res;\n  if (schema.extends) res = serializeWithSchema(schema.extends, obj);else {\n    // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n    res = {};\n  }\n  Object.keys(schema.props).forEach(function (key) {\n    var propDef = schema.props[key];\n\n    if (key === \"*\") {\n      serializeStarProps(schema, propDef, obj, res);\n      return;\n    }\n\n    if (propDef === true) propDef = _defaultPrimitiveProp;\n    if (propDef === false) return;\n    var jsonValue = propDef.serializer(obj[key], key, obj);\n\n    if (jsonValue === SKIP) {\n      return;\n    }\n\n    res[propDef.jsonname || key] = jsonValue;\n  });\n  return res;\n}\n\nfunction serializeStarProps(schema, propDef, obj, target) {\n  checkStarSchemaInvariant(propDef);\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n      if (propDef === true || propDef.pattern && propDef.pattern.test(key)) {\n        var value = obj[key];\n\n        if (propDef === true) {\n          if (isPrimitive(value)) {\n            target[key] = value;\n          }\n        } else if (propDef.props) {\n          var jsonValue = serialize(propDef, value);\n\n          if (jsonValue === SKIP) {\n            return;\n          } // todo: propDef.jsonname could be a transform function on key\n\n\n          target[key] = jsonValue;\n        } else {\n          var jsonValue = propDef.serializer(value, key, obj);\n\n          if (jsonValue === SKIP) {\n            return;\n          } // todo: propDef.jsonname could be a transform function on key\n\n\n          target[key] = jsonValue;\n        }\n      }\n    }\n  }\n}\n\nvar rootContextCache = new WeakMap();\n\nfunction Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n  this.parentContext = parentContext;\n  this.isRoot = !parentContext;\n  this.pendingCallbacks = 0;\n  this.pendingRefsCount = 0;\n  this.onReadyCb = onReadyCb || GUARDED_NOOP;\n  this.json = json;\n  this.target = null; // always set this property using setTarget\n\n  this.hasError = false;\n  this.modelSchema = modelSchema;\n\n  if (this.isRoot) {\n    this.rootContext = this;\n    this.args = customArgs;\n    this.pendingRefs = {}; // uuid: [{ modelSchema, uuid, cb }]\n\n    this.resolvedRefs = {}; // uuid: [{ modelSchema, value }]\n  } else {\n    this.rootContext = parentContext.rootContext;\n    this.args = parentContext.args;\n  }\n}\n\nContext.prototype.createCallback = function (fn) {\n  this.pendingCallbacks++; // once: defend against user-land calling 'done' twice\n\n  return once(function (err, value) {\n    if (err) {\n      if (!this.hasError) {\n        this.hasError = true;\n        this.onReadyCb(err);\n        rootContextCache.delete(this);\n      }\n    } else if (!this.hasError) {\n      fn(value);\n\n      if (--this.pendingCallbacks === this.pendingRefsCount) {\n        if (this.pendingRefsCount > 0) {\n          // all pending callbacks are pending reference resolvers. not good.\n          this.onReadyCb(new Error(\"Unresolvable references in json: \\\"\" + Object.keys(this.pendingRefs).filter(function (uuid) {\n            return this.pendingRefs[uuid].length > 0;\n          }, this).join(\"\\\", \\\"\") + \"\\\"\"));\n          rootContextCache.delete(this);\n        } else {\n          this.onReadyCb(null, this.target);\n          rootContextCache.delete(this);\n        }\n      }\n    }\n  }.bind(this));\n}; // given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n// resolve immediately if possible\n\n\nContext.prototype.await = function (modelSchema, uuid, callback) {\n  invariant(this.isRoot);\n\n  if (uuid in this.resolvedRefs) {\n    var match = this.resolvedRefs[uuid].filter(function (resolved) {\n      return isAssignableTo(resolved.modelSchema, modelSchema);\n    })[0];\n    if (match) return void callback(null, match.value);\n  }\n\n  this.pendingRefsCount++;\n  if (!this.pendingRefs[uuid]) this.pendingRefs[uuid] = [];\n  this.pendingRefs[uuid].push({\n    modelSchema: modelSchema,\n    uuid: uuid,\n    callback: callback\n  });\n}; // given a model schema, uuid and value, resolve all references that where looking for this object\n\n\nContext.prototype.resolve = function (modelSchema, uuid, value) {\n  invariant(this.isRoot);\n  if (!this.resolvedRefs[uuid]) this.resolvedRefs[uuid] = [];\n  this.resolvedRefs[uuid].push({\n    modelSchema: modelSchema,\n    value: value\n  });\n\n  if (uuid in this.pendingRefs) {\n    for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n      var opts = this.pendingRefs[uuid][i];\n\n      if (isAssignableTo(modelSchema, opts.modelSchema)) {\n        this.pendingRefs[uuid].splice(i, 1);\n        this.pendingRefsCount--;\n        opts.callback(null, value);\n      }\n    }\n  }\n}; // set target and update root context cache\n\n\nContext.prototype.setTarget = function (target) {\n  if (this.isRoot && this.target) {\n    rootContextCache.delete(this.target);\n  }\n\n  this.target = target;\n  rootContextCache.set(this.target, this);\n}; // call all remaining reference lookup callbacks indicating an error during ref resolution\n\n\nContext.prototype.cancelAwaits = function () {\n  invariant(this.isRoot);\n  var self = this;\n  Object.keys(this.pendingRefs).forEach(function (uuid) {\n    self.pendingRefs[uuid].forEach(function (refOpts) {\n      self.pendingRefsCount--;\n      refOpts.callback(new Error(\"Reference resolution canceled for \" + uuid));\n    });\n  });\n  this.pendingRefs = {};\n  this.pendingRefsCount = 0;\n};\n\nfunction getTargetContext(target) {\n  return rootContextCache.get(target);\n}\n/*\n * Deserialization\n */\n\n\nfunction schemaHasAlias(schema, name) {\n  for (var key in schema.props) {\n    if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name) return true;\n  }\n\n  return false;\n}\n\nfunction deserializeStarProps(context, schema, propDef, obj, json) {\n  checkStarSchemaInvariant(propDef);\n\n  for (var key in json) {\n    if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n      var jsonValue = json[key];\n\n      if (propDef === true) {\n        // when deserializing we don't want to silently ignore 'unparseable data' to avoid\n        // confusing bugs\n        invariant(isPrimitive(jsonValue), \"encountered non primitive value while deserializing '*' properties in property '\" + key + \"': \" + jsonValue);\n        obj[key] = jsonValue;\n      } else if (propDef.pattern.test(key)) {\n        if (propDef.factory) {\n          var resultValue = deserializeObjectWithSchema(context, propDef, jsonValue, context.callback || GUARDED_NOOP, {}); // deserializeObjectWithSchema returns undefined on error\n\n          if (resultValue !== undefined) {\n            obj[key] = resultValue;\n          }\n        } else {\n          var setValue = function setValue(resultValue) {\n            if (resultValue !== SKIP) {\n              obj[key] = resultValue;\n            }\n          };\n\n          propDef.deserializer(jsonValue, // for individual props, use root context based callbacks\n          // this allows props to complete after completing the object itself\n          // enabling reference resolving and such\n          context.rootContext.createCallback(setValue), context);\n        }\n      }\n    }\n  }\n}\n/**\n * Deserializes a json structure into an object graph.\n *\n * This process might be asynchronous (for example if there are references with an asynchronous\n * lookup function). The function returns an object (or array of objects), but the returned object\n * might be incomplete until the callback has fired as well (which might happen immediately)\n *\n * @param {object|array} schema to use for deserialization\n * @param {json} json data to deserialize\n * @param {function} callback node style callback that is invoked once the deserialization has\n *   finished. First argument is the optional error, second argument is the deserialized object\n *   (same as the return value)\n * @param {*} customArgs custom arguments that are available as `context.args` during the\n *   deserialization process. This can be used as dependency injection mechanism to pass in, for\n *   example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\n\n\nfunction deserialize(schema, json, callback, customArgs) {\n  invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\");\n  schema = getDefaultModelSchema(schema);\n  invariant(isModelSchema(schema), \"first argument should be model schema\");\n\n  if (Array.isArray(json)) {\n    var items = [];\n    parallel(json, function (childJson, itemDone) {\n      var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs); // instance is created synchronously so can be pushed\n\n      items.push(instance);\n    }, callback || GUARDED_NOOP);\n    return items;\n  } else return deserializeObjectWithSchema(null, schema, json, callback, customArgs);\n}\n\nfunction deserializeObjectWithSchema(parentContext, modelSchema, json, callback, customArgs) {\n  if (json === null || json === undefined || typeof json !== \"object\") return void callback(null, null);\n  var context = new Context(parentContext, modelSchema, json, callback, customArgs);\n  var target = modelSchema.factory(context); // todo async invariant\n\n  invariant(!!target, \"No object returned from factory\"); // TODO: make invariant?            invariant(schema.extends ||\n  // !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable\n  // supertype, but modelschema did not provide extends clause\")\n\n  context.setTarget(target);\n  var lock = context.createCallback(GUARDED_NOOP);\n  deserializePropsWithSchema(context, modelSchema, json, target);\n  lock();\n  return target;\n}\n\nfunction deserializePropsWithSchema(context, modelSchema, json, target) {\n  if (modelSchema.extends) deserializePropsWithSchema(context, modelSchema.extends, json, target);\n\n  function deserializeProp(propDef, jsonValue, propName) {\n    function setValue(value) {\n      if (value !== SKIP) {\n        target[propName] = value;\n      }\n    }\n\n    function preProcess(resultCallback) {\n      return function (err, newValue) {\n        function finalCallback(errPreliminary, finalOrRetryValue) {\n          if (errPreliminary && finalOrRetryValue !== undefined && typeof propDef.afterDeserialize === \"function\") {\n            propDef.deserializer(finalOrRetryValue, preProcess(resultCallback), context, target[propName]);\n          } else {\n            resultCallback(errPreliminary, finalOrRetryValue);\n          }\n        }\n\n        onAfterDeserialize(finalCallback, err, newValue, jsonValue, json, propName, context, propDef);\n      };\n    }\n\n    propDef.deserializer(jsonValue, // for individual props, use root context based callbacks\n    // this allows props to complete after completing the object itself\n    // enabling reference resolving and such\n    preProcess(context.rootContext.createCallback(setValue)), context, target[propName] // initial value\n    );\n  }\n\n  Object.keys(modelSchema.props).forEach(function (propName) {\n    var propDef = modelSchema.props[propName];\n\n    function callbackDeserialize(err, jsonValue) {\n      if (!err && jsonValue !== undefined) {\n        deserializeProp(propDef, jsonValue, propName);\n      }\n    }\n\n    if (propName === \"*\") {\n      deserializeStarProps(context, modelSchema, propDef, target, json);\n      return;\n    }\n\n    if (propDef === true) propDef = _defaultPrimitiveProp;\n    if (propDef === false) return;\n    var jsonAttr = propDef.jsonname || propName;\n    var jsonValue = json[jsonAttr];\n    onBeforeDeserialize(callbackDeserialize, jsonValue, json, jsonAttr, context, propDef);\n  });\n}\n\nfunction onBeforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n  if (propDef && typeof propDef.beforeDeserialize === \"function\") {\n    propDef.beforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef);\n  } else {\n    callback(null, jsonValue);\n  }\n}\n\nfunction onAfterDeserialize(callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n  if (propDef && typeof propDef.afterDeserialize === \"function\") {\n    propDef.afterDeserialize(callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef);\n  } else {\n    callback(err, newValue);\n  }\n}\n/**\n * `object` indicates that this property contains an object that needs to be (de)serialized\n * using its own model schema.\n *\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class SubTask {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: object(SubTask),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: {\n *         title: 'Sub task',\n *     },\n * });\n *\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction object(modelSchema, additionalArgs) {\n  invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\");\n  var result = {\n    serializer: function serializer(item) {\n      modelSchema = getDefaultModelSchema(modelSchema);\n      invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema);\n      if (item === null || item === undefined) return item;\n      return serialize(modelSchema, item);\n    },\n    deserializer: function deserializer(childJson, done, context) {\n      modelSchema = getDefaultModelSchema(modelSchema);\n      invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema);\n      if (childJson === null || childJson === undefined) return void done(null, childJson);\n      return void deserializeObjectWithSchema(context, modelSchema, childJson, done, additionalArgs);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * The `serializeAll` decorator can may used on a class to signal that all primitive properties,\n * or complex properties with a name matching a `pattern`, should be serialized automatically.\n *\n * @example\n * @serializeAll class Store {\n *     a = 3;\n *     b;\n * }\n *\n * const store = new Store();\n * store.c = 5;\n * store.d = {};\n * t.deepEqual(serialize(store), { c: 5 });\n *\n * @example\n * class DataType {\n *     @serializable\n *     x;\n *     @serializable\n *     y;\n * }\n * @serializeAll(/^[a-z]$/, DataType) class ComplexStore {\n * }\n *\n * const store = new ComplexStore();\n * store.a = {x: 1, y: 2};\n * store.b = {};\n * store.somethingElse = 5;\n * t.deepEqual(serialize(store), { a: {x: 1, y: 2}, b: { x: undefined, y: undefined } });\n */\n\n\nfunction serializeAll(targetOrPattern, clazzOrSchema) {\n  var propSchema;\n  var invokeImmediately = false;\n\n  if (arguments.length === 1) {\n    invariant(typeof targetOrPattern === \"function\", \"@serializeAll can only be used as class decorator\");\n    propSchema = true;\n    invokeImmediately = true;\n  } else {\n    invariant(typeof targetOrPattern === \"object\" && targetOrPattern.test, \"@serializeAll pattern doesn't have test\");\n\n    if (typeof clazzOrSchema === \"function\") {\n      clazzOrSchema = object(clazzOrSchema);\n    }\n\n    invariant(typeof clazzOrSchema === \"object\" && clazzOrSchema.serializer, \"couldn't resolve schema\");\n    propSchema = Object.assign({}, clazzOrSchema, {\n      pattern: targetOrPattern\n    });\n  }\n\n  function result(target) {\n    var info = getDefaultModelSchema(target);\n\n    if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n      info = createModelSchema(target, {});\n      setDefaultModelSchema(target, info);\n    }\n\n    getDefaultModelSchema(target).props[\"*\"] = propSchema;\n    return target;\n  }\n\n  if (invokeImmediately) {\n    return result(targetOrPattern);\n  }\n\n  return result;\n}\n/*\n * Deserialization\n */\n\n/**\n * Cancels an asynchronous deserialization or update operation for the specified target object.\n * @param instance object that was previously returned from deserialize or update method\n */\n\n\nfunction cancelDeserialize(instance) {\n  invariant(typeof instance === \"object\" && instance && !Array.isArray(instance), \"cancelDeserialize needs an object\");\n  var context = getTargetContext(instance);\n\n  if (context) {\n    context.cancelAwaits();\n  }\n}\n/*\n * Update\n */\n\n/**\n * Similar to deserialize, but updates an existing object instance.\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\n * Further this method behaves similar to deserialize.\n *\n * @param {object} modelSchema, optional if it can be inferred from the instance type\n * @param {object} target target instance to update\n * @param {object} json the json to deserialize\n * @param {function} callback the callback to invoke once deserialization has completed.\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\n\n\nfunction update(modelSchema, target, json, callback, customArgs) {\n  var inferModelSchema = arguments.length === 2 // only target and json\n  || typeof arguments[2] === \"function\"; // callback as third arg\n\n  if (inferModelSchema) {\n    target = arguments[0];\n    modelSchema = getDefaultModelSchema(target);\n    json = arguments[1];\n    callback = arguments[2];\n    customArgs = arguments[3];\n  } else {\n    modelSchema = getDefaultModelSchema(modelSchema);\n  }\n\n  invariant(isModelSchema(modelSchema), \"update failed to determine schema\");\n  invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\");\n  var context = new Context(null, modelSchema, json, callback, customArgs);\n  context.setTarget(target);\n  var lock = context.createCallback(GUARDED_NOOP);\n  var result = deserializePropsWithSchema(context, modelSchema, json, target);\n  lock();\n  return result;\n}\n\nfunction defaultRegisterFunction(id, value, context) {\n  context.rootContext.resolve(context.modelSchema, id, context.target);\n}\n/**\n *\n *\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n * This is used by for example `reference()` to serialize the reference\n *\n * Identifier accepts an optional `registerFn` with the signature:\n * `(id, target, context) => void`\n * that can be used to register this object in some store. note that not all fields of this object might\n * have been deserialized yet.\n *\n * @example\n * var todos = {};\n *\n * var s = _.createSimpleSchema({\n *     id: _.identifier((id, object) => (todos[id] = object)),\n *     title: true,\n * });\n *\n * _.deserialize(s, {\n *     id: 1,\n *     title: 'test0',\n * });\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\n *\n * t.deepEqual(todos, {\n *     1: { id: 1, title: 'test1' },\n *     2: { id: 2, title: 'test2' },\n * });\n *\n * @param { RegisterFunction | AdditionalPropArgs } arg1 optional registerFn: function to register this object during creation.\n * @param {AdditionalPropArgs} arg2 optional object that contains beforeDeserialize and/or afterDeserialize handlers\n *\n * @returns {PropSchema}\n */\n\n\nfunction identifier(arg1, arg2) {\n  var registerFn, additionalArgs;\n\n  if (typeof arg1 === \"function\") {\n    registerFn = arg1;\n    additionalArgs = arg2;\n  } else {\n    additionalArgs = arg1;\n  }\n\n  invariant(!additionalArgs || typeof additionalArgs === \"object\", \"Additional property arguments should be an object, register function should be omitted or a funtion\");\n  var result = {\n    identifier: true,\n    serializer: _defaultPrimitiveProp.serializer,\n    deserializer: function deserializer(jsonValue, done, context) {\n      _defaultPrimitiveProp.deserializer(jsonValue, function (err, id) {\n        defaultRegisterFunction(id, context.target, context);\n        if (registerFn) registerFn(id, context.target, context);\n        done(err, id);\n      });\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * Similar to primitive, serializes instances of Date objects\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction date(additionalArgs) {\n  // TODO: add format option?\n  var result = {\n    serializer: function serializer(value) {\n      if (value === null || value === undefined) return value;\n      invariant(value instanceof Date, \"Expected Date object\");\n      return value.getTime();\n    },\n    deserializer: function deserializer(jsonValue, done) {\n      if (jsonValue === null || jsonValue === undefined) return void done(null, jsonValue);\n      return void done(null, new Date(jsonValue));\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * Alias indicates that this model property should be named differently in the generated json.\n * Alias should be the outermost propschema.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: alias('task', primitive()),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // { task : \"test\" }\n *\n * @param {string} name name of the json field to be used for this property\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\n\n\nfunction alias(name, propSchema) {\n  invariant(name && typeof name === \"string\", \"expected prop name as first argument\");\n  propSchema = !propSchema || propSchema === true ? _defaultPrimitiveProp : propSchema;\n  invariant(isPropSchema(propSchema), \"expected prop schema as second argument\");\n  invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\");\n  return {\n    jsonname: name,\n    serializer: propSchema.serializer,\n    deserializer: propSchema.deserializer,\n    identifier: isIdentifierPropSchema(propSchema),\n    beforeDeserialize: propSchema.beforeDeserialize,\n    afterDeserialize: propSchema.afterDeserialize\n  };\n}\n/**\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\n\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\n\n * The `serializer` function has the signature:\n * `(value, key, obj) => void`\n\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\n\n * The `deserializer` function has the following signature for synchronous processing\n * `(value, context, oldValue) => void`\n\n * For asynchronous processing the function expects the following signature\n * `(value, context, oldValue, callback) => void`\n\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\n *\n * @example\n * var schemaDefault = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v) {\n *             return v - 2;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaDefault, { a: 4 }), { a: 6 });\n * t.deepEqual(_.deserialize(schemaDefault, { a: 6 }), { a: 4 });\n *\n * var schemaWithAsyncProps = _.createSimpleSchema({\n *     a: _.customAsync(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v, context, oldValue, callback) {\n *             somePromise(v, context, oldValue).then((result) => {\n *                 callback(null, result - 2)\n *             }.catch((err) => {\n *                 callback(err)\n *             }\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaWithAsyncProps, { a: 4 }), { a: 6 });\n * _.deserialize(schemaWithAsyncProps, { a: 6 }, (err, res) => {\n *   t.deepEqual(res.a, 4)\n * };\n\n *\n * @param {function} serializer function that takes a model value and turns it into a json value\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction custom(serializer, _deserializer, additionalArgs) {\n  invariant(typeof serializer === \"function\", \"first argument should be function\");\n  invariant(typeof _deserializer === \"function\", \"second argument should be a function or promise\");\n  var result = {\n    serializer: serializer,\n    deserializer: function deserializer(jsonValue, done, context, oldValue) {\n      if (_deserializer.length === 4) {\n        _deserializer(jsonValue, context, oldValue, done, additionalArgs);\n      } else {\n        done(null, _deserializer(jsonValue, context, oldValue, null, additionalArgs));\n      }\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * Optional indicates that this model property shouldn't be serialized if it isn't present.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: optional(primitive()),\n * });\n *\n * console.dir(serialize(new Todo()));\n * // {}\n *\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\n\n\nfunction optional(name, propSchema) {\n  propSchema = !propSchema || propSchema === true ? _defaultPrimitiveProp : propSchema;\n  invariant(isPropSchema(propSchema), \"expected prop schema as second argument\");\n  var propSerializer = propSchema.serializer;\n  invariant(typeof propSerializer === \"function\", \"expected prop schema to have a callable serializer\");\n\n  function serializer() {\n    var result = propSerializer.apply(void 0, arguments);\n\n    if (result === undefined) {\n      return SKIP;\n    }\n\n    return result;\n  }\n\n  return Object.assign({}, propSchema, {\n    serializer: serializer\n  });\n}\n\nfunction createDefaultRefLookup(modelSchema) {\n  return function resolve(uuid, cb, context) {\n    context.rootContext.await(modelSchema, uuid, cb);\n  };\n}\n/**\n * `reference` can be used to (de)serialize references that point to other models.\n *\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n * or a string that represents which attribute in the target object represents the identifier of the object.\n *\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n * an object. Its signature should be as follows:\n *\n * `lookupFunction(identifier, callback, context)` where:\n * 1. `identifier` is the identifier being resolved\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n * 3. `context` see context.\n *\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n *\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class User {}\n * class Post {}\n *\n * createModelSchema(User, {\n *     uuid: identifier(),\n *     displayname: primitive(),\n * });\n *\n * createModelSchema(Post, {\n *     author: reference(User, findUserById),\n *     message: primitive(),\n * });\n *\n * function findUserById(uuid, callback) {\n *     fetch('http://host/user/' + uuid)\n *         .then(userData => {\n *             deserialize(User, userData, callback);\n *         })\n *         .catch(callback);\n * }\n *\n * deserialize(\n *     Post,\n *     {\n *         message: 'Hello World',\n *         author: 234,\n *     },\n *     (err, post) => {\n *         console.log(post);\n *     }\n * );\n *\n * @param target: ModelSchema or string\n * @param {RefLookupFunction | AdditionalPropArgs} lookupFn optional function or additionalArgs object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction reference(target, lookupFn, additionalArgs) {\n  invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\");\n  var initialized = false;\n  var childIdentifierAttribute;\n\n  if (typeof lookupFn === \"object\" && additionalArgs === undefined) {\n    additionalArgs = lookupFn;\n    lookupFn = undefined;\n  }\n\n  function initialize() {\n    initialized = true;\n    invariant(typeof target !== \"string\" || lookupFn && typeof lookupFn === \"function\", \"if the reference target is specified by attribute name, a lookup function is required\");\n    invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function or additional arguments object\");\n    if (typeof target === \"string\") childIdentifierAttribute = target;else {\n      var modelSchema = getDefaultModelSchema(target);\n      invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema);\n      lookupFn = lookupFn || createDefaultRefLookup(modelSchema);\n      childIdentifierAttribute = getIdentifierProp(modelSchema);\n      invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\");\n    }\n  }\n\n  var result = {\n    serializer: function serializer(item) {\n      if (!initialized) initialize();\n      return item ? item[childIdentifierAttribute] : null;\n    },\n    deserializer: function deserializer(identifierValue, done, context) {\n      if (!initialized) initialize();\n      if (identifierValue === null || identifierValue === undefined) done(null, identifierValue);else lookupFn(identifierValue, done, context);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * List indicates that this property contains a list of things.\n * Accepts a sub model schema to serialize the contents\n *\n * @example\n * class SubTask {}\n * class Task {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: list(object(SubTask)),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: [\n *         {\n *             title: 'Sub task 1',\n *         },\n *     ],\n * });\n *\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction list(propSchema, additionalArgs) {\n  propSchema = propSchema || _defaultPrimitiveProp;\n  invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n  invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\");\n  var result = {\n    serializer: function serializer(ar) {\n      if (ar === undefined) {\n        return SKIP;\n      }\n\n      invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\");\n      return ar.map(propSchema.serializer);\n    },\n    deserializer: function deserializer(jsonArray, done, context) {\n      if (!Array.isArray(jsonArray)) return void done(\"[serializr] expected JSON array\");\n\n      function processItem(jsonValue, onItemDone, itemIndex) {\n        function callbackBefore(err, value) {\n          if (!err) {\n            propSchema.deserializer(value, deserializeDone, context);\n          } else {\n            onItemDone(err);\n          }\n        }\n\n        function deserializeDone(err, value) {\n          if (typeof propSchema.afterDeserialize === \"function\") {\n            onAfterDeserialize(callbackAfter, err, value, jsonValue, itemIndex, context, propSchema);\n          } else {\n            onItemDone(err, value);\n          }\n        }\n\n        function callbackAfter(errPreliminary, finalOrRetryValue) {\n          if (errPreliminary && finalOrRetryValue !== undefined && typeof propSchema.afterDeserialize === \"function\") {\n            propSchema.deserializer(finalOrRetryValue, deserializeDone, context);\n          } else {\n            onItemDone(errPreliminary, finalOrRetryValue);\n          }\n        }\n\n        onBeforeDeserialize(callbackBefore, jsonValue, jsonArray, itemIndex, context, propSchema);\n      }\n\n      parallel(jsonArray, processItem, done);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/**\n * Similar to list, but map represents a string keyed dynamic collection.\n * This can be both plain objects (default) or ES6 Map like structures.\n * This will be inferred from the initial value of the targetted attribute.\n *\n * @param {*} propSchema\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction map(propSchema, additionalArgs) {\n  propSchema = propSchema || _defaultPrimitiveProp;\n  invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n  invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\");\n  var res = {\n    serializer: function serializer(m) {\n      invariant(m && typeof m === \"object\", \"expected object or Map\");\n      var isMap = isMapLike(m);\n      var result = {};\n      if (isMap) m.forEach(function (value, key) {\n        result[key] = propSchema.serializer(value);\n      });else for (var key in m) {\n        result[key] = propSchema.serializer(m[key]);\n      }\n      return result;\n    },\n    deserializer: function deserializer(jsonObject, done, context, oldValue) {\n      if (!jsonObject || typeof jsonObject !== \"object\") return void done(\"[serializr] expected JSON object\");\n      var keys = Object.keys(jsonObject);\n      list(propSchema, additionalArgs).deserializer(keys.map(function (key) {\n        return jsonObject[key];\n      }), function (err, values) {\n        if (err) return void done(err);\n        var isMap = isMapLike(oldValue);\n        var newValue;\n\n        if (isMap) {\n          // if the oldValue is a map, we recycle it\n          // there are many variations and this way we don't have to\n          // know about the original constructor\n          oldValue.clear();\n          newValue = oldValue;\n        } else newValue = {};\n\n        for (var i = 0, l = keys.length; i < l; i++) {\n          if (isMap) newValue.set(keys[i], values[i]);else newValue[keys[i]] = values[i];\n        }\n\n        done(null, newValue);\n      }, context);\n    }\n  };\n  res = processAdditionalPropArgs(res, additionalArgs);\n  return res;\n}\n/**\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is\n * contained in the 'value object'. Example: consider Map<id: number, customer: Customer> where the\n * Customer object has the id stored on itself. mapAsArray stores all values from the map into an\n * array which is serialized. Deserialization returns a ES6 Map or plain object object where the\n * `keyPropertyName` of each object is used for keys. For ES6 maps this has the benefit of being\n * allowed to have non-string keys in the map. The serialized json also may be slightly more\n * compact.\n *\n * @param {any} propSchema\n * @param {string} keyPropertyName - the property of stored objects used as key in the map\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\n\n\nfunction mapAsArray(propSchema, keyPropertyName, additionalArgs) {\n  propSchema = propSchema || _defaultPrimitiveProp;\n  invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n  invariant(!!keyPropertyName, \"expected key property name as second argument\");\n  var res = {\n    serializer: function serializer(m) {\n      invariant(m && typeof m === \"object\", \"expected object or Map\");\n      var isMap = isMapLike(m);\n      var result = []; // eslint-disable-next-line no-unused-vars\n\n      if (isMap) {\n        m.forEach(function (value) {\n          result.push(propSchema.serializer(value));\n        });\n      } else for (var key in m) {\n        result.push(propSchema.serializer(m[key])); // result[key] = propSchema.serializer(m[key])\n      }\n\n      return result;\n    },\n    deserializer: function deserializer(jsonArray, done, context, oldValue) {\n      list(propSchema, additionalArgs).deserializer(jsonArray, function (err, values) {\n        if (err) return void done(err);\n        var isMap = isMapLike(oldValue);\n        var newValue;\n\n        if (isMap) {\n          oldValue.clear();\n          newValue = oldValue;\n        } else {\n          newValue = {};\n        }\n\n        for (var i = 0, l = jsonArray.length; i < l; i++) {\n          if (isMap) newValue.set(values[i][keyPropertyName], values[i]);else newValue[values[i][keyPropertyName].toString()] = values[i];\n        }\n\n        done(null, newValue);\n      }, context);\n    }\n  };\n  res = processAdditionalPropArgs(res, additionalArgs);\n  return res;\n}\n/**\n * Indicates that this field is only need to putted in the serialized json or\n * deserialized instance, without any transformations. Stay with its original value\n *\n * @example\n * createModelSchema(Model, {\n *     rawData: raw(),\n * });\n *\n * console.dir(serialize(new Model({ rawData: { a: 1, b: [], c: {} } } })));\n * // outputs: { rawData: { a: 1, b: [], c: {} } } }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\n\n\nfunction raw(additionalArgs) {\n  var result = {\n    serializer: function serializer(value) {\n      return value;\n    },\n    deserializer: function deserializer(jsonValue, done) {\n      return void done(null, jsonValue);\n    }\n  };\n  result = processAdditionalPropArgs(result, additionalArgs);\n  return result;\n}\n/*\n * ## Managing model schemas\n */\n// ~ deprecated\n\n\nexport { createSimpleSchema, createModelSchema, getDefaultModelSchema, setDefaultModelSchema, serializable, serialize, serializeAll, cancelDeserialize, deserialize, update, primitive, identifier, date, alias, custom, object, object as child, optional, reference, reference as ref, list, map, mapAsArray, raw, SKIP };","map":{"version":3,"sources":["C:/Users/tomsa/OneDrive/Desktop/ReactExampleCode/test-typescript-compile-within-a-javascript-project/Code/node_modules/serializr/lib/es/serializr.js"],"names":["createSimpleSchema","props","factory","formatters","j","json","v","JSON","stringify","error","message","invariant","condition","variables","Array","prototype","slice","call","arguments","variablesToLog","index","formattedMessage","replace","messageFormatter","match","format","formatter","variable","push","console","length","log","apply","Error","GUARDED_NOOP","err","once","fn","fired","parallel","ar","processor","cb","left","filter","resultArray","failed","processorCb","idx","result","forEach","value","bind","isPrimitive","isModelSchema","thing","isPropSchema","serializer","deserializer","isAliasedPropSchema","propSchema","jsonname","isIdentifierPropSchema","identifier","isAssignableTo","actualType","expectedType","extends","isMapLike","keys","clear","getIdentifierProp","modelSchema","propName","processAdditionalPropArgs","additionalArgs","argNames","argName","getDefaultModelSchema","serializeInfo","constructor","setDefaultModelSchema","clazz","createModelSchema","Object","model","targetClass","s","primitive","jsonValue","done","SKIP","Symbol","_defaultPrimitiveProp","STRIP_COMMENTS","ARGUMENT_NAMES","getParamNames","func","fnStr","toString","indexOf","serializableDecorator","target","descriptor","undefined","paramNames","paramNumber","context","params","i","key","prop","Function","concat","info","hasOwnProperty","get","set","writable","serializable","arg1","arg2","arg3","serialize","schema","isArray","map","item","serializeWithSchema","checkStarSchemaInvariant","propDef","pattern","obj","res","serializeStarProps","test","rootContextCache","WeakMap","Context","parentContext","onReadyCb","customArgs","isRoot","pendingCallbacks","pendingRefsCount","hasError","rootContext","args","pendingRefs","resolvedRefs","createCallback","delete","uuid","join","await","callback","resolved","resolve","opts","splice","setTarget","cancelAwaits","self","refOpts","getTargetContext","schemaHasAlias","name","deserializeStarProps","resultValue","deserializeObjectWithSchema","setValue","deserialize","items","childJson","itemDone","instance","lock","deserializePropsWithSchema","deserializeProp","preProcess","resultCallback","newValue","finalCallback","errPreliminary","finalOrRetryValue","afterDeserialize","onAfterDeserialize","callbackDeserialize","jsonAttr","onBeforeDeserialize","jsonParentValue","propNameOrIndex","beforeDeserialize","object","serializeAll","targetOrPattern","clazzOrSchema","invokeImmediately","assign","cancelDeserialize","update","inferModelSchema","defaultRegisterFunction","id","registerFn","date","Date","getTime","alias","custom","oldValue","optional","propSerializer","createDefaultRefLookup","reference","lookupFn","initialized","childIdentifierAttribute","initialize","identifierValue","list","jsonArray","processItem","onItemDone","itemIndex","callbackBefore","deserializeDone","callbackAfter","m","isMap","jsonObject","values","l","mapAsArray","keyPropertyName","raw","child","ref"],"mappings":"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","sourcesContent":["/**\n * Creates a model schema that (de)serializes from / to plain javascript objects.\n * Its factory method is: `() => ({})`\n *\n * @example\n * var todoSchema = createSimpleSchema({\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(todoSchema, { title: 'Test', done: false });\n * var todo = deserialize(todoSchema, json);\n *\n * @param {object} props property mapping,\n * @returns {object} model schema\n */\nfunction createSimpleSchema(props) {\n    return {\n        factory: function() {\n            return {}\n        },\n        props: props\n    }\n}\n\nvar formatters = {\n    j: function json(v) {\n        try {\n            return JSON.stringify(v)\n        } catch (error) {\n            return \"[UnexpectedJSONParseError]: \" + error.message\n        }\n    }\n};\n\nfunction invariant(condition, message) {\n    if (!condition) {\n        var variables = Array.prototype.slice.call(arguments, 2);\n        var variablesToLog = [];\n\n        var index = 0;\n        var formattedMessage = message.replace(/%([a-zA-Z%])/g, function messageFormatter(match, format) {\n            if (match === \"%%\") return match\n\n            var formatter = formatters[format];\n\n            if (typeof formatter === \"function\") {\n                var variable = variables[index++];\n\n                variablesToLog.push(variable);\n\n                return formatter(variable)\n            }\n\n            return match\n        });\n\n        if (console && variablesToLog.length > 0) {\n            // eslint-disable-next-line no-console\n            console.log.apply(console, variablesToLog);\n        }\n\n        throw new Error(\"[serializr] \" + (formattedMessage || \"Illegal State\"))\n    }\n}\n\nfunction GUARDED_NOOP(err) {\n    if (err) // unguarded error...\n        throw new Error(err)\n}\n\nfunction once(fn) {\n    var fired = false;\n    return function () {\n        if (!fired) {\n            fired = true;\n            return fn.apply(null, arguments)\n        }\n        invariant(false, \"callback was invoked twice\");\n    }\n}\n\nfunction parallel(ar, processor, cb) {\n    // TODO: limit parallelization?\n    if (ar.length === 0)\n        return void cb(null, [])\n    var left = ar.filter(function(){ return true }).length; // only count items processed by forEach\n    var resultArray = [];\n    var failed = false;\n    var processorCb = function (idx, err, result) {\n        if (err) {\n            if (!failed) {\n                failed = true;\n                cb(err);\n            }\n        } else {\n            resultArray[idx] = result;\n            if (--left === 0)\n                cb(null, resultArray);\n        }\n    };\n    ar.forEach(function (value, idx) {\n        processor(value, processorCb.bind(null, idx), idx);\n    });\n}\n\nfunction isPrimitive(value) {\n    if (value === null)\n        return true\n    return typeof value !== \"object\" && typeof value !== \"function\"\n}\n\nfunction isModelSchema(thing) {\n    return thing && thing.factory && thing.props\n}\n\nfunction isPropSchema(thing) {\n    return thing && thing.serializer && thing.deserializer\n}\n\nfunction isAliasedPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && !!propSchema.jsonname\n}\n\nfunction isIdentifierPropSchema(propSchema) {\n    return typeof propSchema === \"object\" && propSchema.identifier === true\n}\n\nfunction isAssignableTo(actualType, expectedType) {\n    while (actualType) {\n        if (actualType === expectedType)\n            return true\n        actualType = actualType.extends;\n    }\n    return false\n}\n\nfunction isMapLike(thing) {\n    return thing && typeof thing.keys === \"function\" && typeof thing.clear === \"function\"\n}\n\nfunction getIdentifierProp(modelSchema) {\n    invariant(isModelSchema(modelSchema));\n    // optimization: cache this lookup\n    while (modelSchema) {\n        for (var propName in modelSchema.props)\n            if (typeof modelSchema.props[propName] === \"object\" && modelSchema.props[propName].identifier === true)\n                return propName\n        modelSchema = modelSchema.extends;\n    }\n    return null\n}\n\nfunction processAdditionalPropArgs(propSchema, additionalArgs) {\n    if (additionalArgs) {\n        invariant(isPropSchema(propSchema), \"expected a propSchema\");\n        var argNames = [\"beforeDeserialize\", \"afterDeserialize\"];\n        argNames.forEach(function(argName) {\n            if (typeof additionalArgs[argName] === \"function\") {\n                propSchema[argName] = additionalArgs[argName];\n            }\n        });\n    }\n    return propSchema\n}\n\n/**\n * Returns the standard model schema associated with a class / constructor function\n *\n * @param {object} thing\n * @returns {ModelSchema} model schema\n */\nfunction getDefaultModelSchema(thing) {\n    if (!thing)\n        return null\n    if (isModelSchema(thing))\n        return thing\n    if (isModelSchema(thing.serializeInfo))\n        return thing.serializeInfo\n    if (thing.constructor && thing.constructor.serializeInfo)\n        return thing.constructor.serializeInfo\n}\n\n/**\n * Sets the default model schema for class / constructor function.\n * Everywhere where a model schema is required as argument, this class / constructor function\n * can be passed in as well (for example when using `object` or `ref`.\n *\n * When passing an instance of this class to `serialize`, it is not required to pass the model schema\n * as first argument anymore, because the default schema will be inferred from the instance type.\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {ModelSchema} modelSchema - a model schema\n * @returns {ModelSchema} model schema\n */\nfunction setDefaultModelSchema(clazz, modelSchema) {\n    invariant(isModelSchema(modelSchema));\n    return clazz.serializeInfo = modelSchema\n}\n\n/**\n * Creates a model schema that (de)serializes an object created by a constructor function (class).\n * The created model schema is associated by the targeted type as default model schema, see setDefaultModelSchema.\n * Its factory method is `() => new clazz()` (unless overriden, see third arg).\n *\n * @example\n * function Todo(title, done) {\n *     this.title = title;\n *     this.done = done;\n * }\n *\n * createModelSchema(Todo, {\n *     title: true,\n *     done: true,\n * });\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param {constructor|class} clazz class or constructor function\n * @param {object} props property mapping\n * @param {function} factory optional custom factory. Receives context as first arg\n * @returns {object} model schema\n */\nfunction createModelSchema(clazz, props, factory) {\n    invariant(clazz !== Object, \"one cannot simply put define a model schema for Object\");\n    invariant(typeof clazz === \"function\", \"expected constructor function\");\n    var model = {\n        targetClass: clazz,\n        factory: factory || function() {\n            return new clazz()\n        },\n        props: props\n    };\n    // find super model\n    if (clazz.prototype.constructor !== Object) {\n        var s = getDefaultModelSchema(clazz.prototype.constructor);\n        if (s && s.targetClass !== clazz)\n            model.extends = s;\n    }\n    setDefaultModelSchema(clazz, model);\n    return model\n}\n\n/**\n * Indicates that this field contains a primitive value (or Date) which should be serialized literally to json.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: primitive(),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // outputs: { title : \"test\" }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\nfunction primitive(additionalArgs) {\n    var result = {\n        serializer: function (value) {\n            invariant(isPrimitive(value), \"this value is not primitive: \" + value);\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            if (!isPrimitive(jsonValue))\n                return void done(\"[serializr] this value is not primitive: \" + jsonValue)\n            return void done(null, jsonValue)\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/**\n * In the event that a property needs to be deserialized, but not serialized, you can use the SKIP symbol to omit the property. This has to be used with the custom serializer.\n *\n * @example\n * var schema = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return _.SKIP\n *         },\n *         function(v) {\n *             return v;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(s, { a: 4 }), { });\n * t.deepEqual(_.deserialize(s, { a: 4 }), { a: 4 });\n */\nvar SKIP = typeof Symbol !== \"undefined\" ? Symbol(\"SKIP\") : { SKIP: true };\n\nvar _defaultPrimitiveProp = primitive();\n\n// Ugly way to get the parameter names since they aren't easily retrievable via reflection\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n\nfunction getParamNames(func) {\n    var fnStr = func.toString().replace(STRIP_COMMENTS, \"\");\n    var result = fnStr.slice(fnStr.indexOf(\"(\")+1, fnStr.indexOf(\")\")).match(ARGUMENT_NAMES);\n    if(result === null)\n        result = [];\n    return result\n}\n\nfunction serializableDecorator(propSchema, target, propName, descriptor) {\n    invariant(arguments.length >= 2, \"too few arguments. Please use @serializable as property decorator\");\n    // Fix for @serializable used in class constructor params (typescript)\n    var factory;\n    if (propName === undefined && typeof target === \"function\"\n        && target.prototype\n        && descriptor !== undefined && typeof descriptor === \"number\") {\n        invariant(isPropSchema(propSchema), \"Constructor params must use alias(name)\");\n        invariant(propSchema.jsonname, \"Constructor params must use alias(name)\");\n        var paramNames = getParamNames(target);\n        if (paramNames.length >= descriptor) {\n            propName = paramNames[descriptor];\n            propSchema.paramNumber = descriptor;\n            descriptor = undefined;\n            target = target.prototype;\n            // Create a factory so the constructor is called properly\n            factory = function(context) {\n                var params = [];\n                for (var i = 0; i < target.constructor.length; i++) {\n                    Object.keys(context.modelSchema.props).forEach(function (key) {\n                        var prop = context.modelSchema.props[key];\n                        if (prop.paramNumber === i) {\n                            params[i] = context.json[prop.jsonname];\n                        }\n                    });\n                }\n\n                return new (Function.prototype.bind.apply(target.constructor, [null].concat(params)))\n            };\n        }\n    }\n    invariant(typeof propName === \"string\", \"incorrect usage of @serializable decorator\");\n    var info = getDefaultModelSchema(target);\n\n    if (!info || !target.constructor.hasOwnProperty(\"serializeInfo\"))\n        info = createModelSchema(target.constructor, {}, factory);\n    if (info && info.targetClass !== target.constructor)\n        // fixes typescript issue that tends to copy fields from super constructor to sub constructor in extends\n        info = createModelSchema(target.constructor, {}, factory);\n    info.props[propName] = propSchema;\n    // MWE: why won't babel work without?\n    if (descriptor && !descriptor.get && !descriptor.set)\n        descriptor.writable = true;\n    return descriptor\n}\n\n/**\n * Decorator that defines a new property mapping on the default model schema for the class\n * it is used in.\n *\n * When using typescript, the decorator can also be used on fields declared as constructor arguments (using the `private` / `protected` / `public` keywords).\n * The default factory will then invoke the constructor with the correct arguments as well.\n *\n * @example\n * class Todo {\n *     @serializable(primitive())\n *     title; // shorthand for primitves\n *\n *     @serializable done;\n *\n *     constructor(title, done) {\n *         this.title = title;\n *         this.done = done;\n *     }\n * }\n *\n * var json = serialize(new Todo('Test', false));\n * var todo = deserialize(Todo, json);\n *\n * @param arg1\n * @param arg2\n * @param arg3\n * @returns {PropertyDescriptor}\n */\nfunction serializable(arg1, arg2, arg3) {\n    if (arguments.length === 1) {\n        // decorated with propSchema\n        var propSchema = arg1 === true ? _defaultPrimitiveProp : arg1;\n        invariant(isPropSchema(propSchema), \"@serializable expects prop schema\");\n        return serializableDecorator.bind(null, propSchema)\n    } else {\n        // decorated without arguments, treat as primitive\n        return serializableDecorator(primitive(), arg1, arg2, arg3)\n    }\n}\n\n/**\n * Serializes an object (graph) into json using the provided model schema.\n * The model schema can be omitted if the object type has a default model schema associated with it.\n * If a list of objects is provided, they should have an uniform type.\n *\n * @param arg1 class or modelschema to use. Optional\n * @param arg2 object(s) to serialize\n * @returns {object} serialized representation of the object\n */\nfunction serialize(arg1, arg2) {\n    invariant(arguments.length === 1 || arguments.length === 2, \"serialize expects one or 2 arguments\");\n    var thing = arguments.length === 1 ? arg1 : arg2;\n    var schema = arguments.length === 1 ? null : arg1;\n    if (Array.isArray(thing)) {\n        if (thing.length === 0)\n            return [] // don't bother finding a schema\n        else if (!schema)\n            schema = getDefaultModelSchema(thing[0]);\n        else if (typeof schema !== \"object\")\n            schema = getDefaultModelSchema(schema);\n    } else if (!schema) {\n        schema = getDefaultModelSchema(thing);\n    } else if (typeof schema !== \"object\") {\n        schema = getDefaultModelSchema(schema);\n    }\n    invariant(!!schema, \"Failed to find default schema for \" + arg1);\n    if (Array.isArray(thing))\n        return thing.map(function (item) {\n            return serializeWithSchema(schema, item)\n        })\n    return serializeWithSchema(schema, thing)\n}\n\nfunction checkStarSchemaInvariant(propDef) {\n    invariant(propDef === true || propDef.pattern, \"prop schema '*' can only be used with 'true' or a prop def with a 'pattern': \" + JSON.stringify(propDef));\n}\n\nfunction serializeWithSchema(schema, obj) {\n    invariant(schema && typeof schema === \"object\" && schema.props, \"Expected schema\");\n    invariant(obj && typeof obj === \"object\", \"Expected object\");\n    var res;\n    if (schema.extends)\n        res = serializeWithSchema(schema.extends, obj);\n    else {\n        // TODO: make invariant?:  invariant(!obj.constructor.prototype.constructor.serializeInfo, \"object has a serializable supertype, but modelschema did not provide extends clause\")\n        res = {};\n    }\n    Object.keys(schema.props).forEach(function (key) {\n        var propDef = schema.props[key];\n        if (key === \"*\") {\n            serializeStarProps(schema, propDef, obj, res);\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp;\n        if (propDef === false)\n            return\n        var jsonValue = propDef.serializer(obj[key], key, obj);\n        if (jsonValue === SKIP){\n            return\n        }\n        res[propDef.jsonname || key] = jsonValue;\n    });\n    return res\n}\n\nfunction serializeStarProps(schema, propDef, obj, target) {\n    checkStarSchemaInvariant(propDef);\n    for (var key in obj) if (obj.hasOwnProperty(key)) if (!(key in schema.props)) {\n        if ((propDef === true) || (propDef.pattern && propDef.pattern.test(key))) {\n            var value = obj[key];\n            if (propDef === true) {\n                if (isPrimitive(value)) {\n                    target[key] = value;\n                }\n            } else if (propDef.props) {\n                var jsonValue = serialize(propDef, value);\n                if (jsonValue === SKIP){\n                    return\n                }\n                // todo: propDef.jsonname could be a transform function on key\n                target[key] = jsonValue;\n            } else {\n                var jsonValue = propDef.serializer(value, key, obj);\n                if (jsonValue === SKIP){\n                    return\n                }\n                // todo: propDef.jsonname could be a transform function on key\n                target[key] = jsonValue;\n            }\n        }\n    }\n}\n\nvar rootContextCache = new WeakMap();\n\nfunction Context(parentContext, modelSchema, json, onReadyCb, customArgs) {\n    this.parentContext = parentContext;\n    this.isRoot = !parentContext;\n    this.pendingCallbacks = 0;\n    this.pendingRefsCount = 0;\n    this.onReadyCb = onReadyCb || GUARDED_NOOP;\n    this.json = json;\n    this.target = null; // always set this property using setTarget\n    this.hasError = false;\n    this.modelSchema = modelSchema;\n    if (this.isRoot) {\n        this.rootContext = this;\n        this.args = customArgs;\n        this.pendingRefs = {}; // uuid: [{ modelSchema, uuid, cb }]\n        this.resolvedRefs = {}; // uuid: [{ modelSchema, value }]\n    } else {\n        this.rootContext = parentContext.rootContext;\n        this.args = parentContext.args;\n    }\n}\n\nContext.prototype.createCallback = function (fn) {\n    this.pendingCallbacks++;\n    // once: defend against user-land calling 'done' twice\n    return once(function (err, value) {\n        if (err) {\n            if (!this.hasError) {\n                this.hasError = true;\n                this.onReadyCb(err);\n                rootContextCache.delete(this);\n            }\n        } else if (!this.hasError) {\n            fn(value);\n            if (--this.pendingCallbacks === this.pendingRefsCount) {\n                if (this.pendingRefsCount > 0) {\n                    // all pending callbacks are pending reference resolvers. not good.\n                    this.onReadyCb(new Error(\n                        \"Unresolvable references in json: \\\"\" +\n                        Object.keys(this.pendingRefs).filter(function (uuid) {\n                            return this.pendingRefs[uuid].length > 0\n                        }, this).join(\"\\\", \\\"\") +\n                        \"\\\"\"\n                    ));\n                    rootContextCache.delete(this);\n                } else {\n                    this.onReadyCb(null, this.target);\n                    rootContextCache.delete(this);\n                }\n            }\n        }\n    }.bind(this))\n};\n\n// given an object with uuid, modelSchema, callback, awaits until the given uuid is available\n// resolve immediately if possible\nContext.prototype.await = function (modelSchema, uuid, callback) {\n    invariant(this.isRoot);\n    if (uuid in this.resolvedRefs) {\n        var match = this.resolvedRefs[uuid].filter(function (resolved) {\n            return isAssignableTo(resolved.modelSchema, modelSchema)\n        })[0];\n        if (match)\n            return void callback(null, match.value)\n    }\n    this.pendingRefsCount++;\n    if (!this.pendingRefs[uuid])\n        this.pendingRefs[uuid] = [];\n    this.pendingRefs[uuid].push({\n        modelSchema: modelSchema,\n        uuid: uuid,\n        callback: callback\n    });\n};\n\n// given a model schema, uuid and value, resolve all references that where looking for this object\nContext.prototype.resolve = function (modelSchema, uuid, value) {\n    invariant(this.isRoot);\n    if (!this.resolvedRefs[uuid])\n        this.resolvedRefs[uuid] = [];\n    this.resolvedRefs[uuid].push({\n        modelSchema: modelSchema, value: value\n    });\n    if (uuid in this.pendingRefs) {\n        for (var i = this.pendingRefs[uuid].length - 1; i >= 0; i--) {\n            var opts = this.pendingRefs[uuid][i];\n            if (isAssignableTo(modelSchema, opts.modelSchema)) {\n                this.pendingRefs[uuid].splice(i, 1);\n                this.pendingRefsCount--;\n                opts.callback(null, value);\n            }\n        }\n    }\n};\n\n// set target and update root context cache\nContext.prototype.setTarget = function (target) {\n    if (this.isRoot && this.target) {\n        rootContextCache.delete(this.target);\n    }\n    this.target = target;\n    rootContextCache.set(this.target, this);\n};\n\n// call all remaining reference lookup callbacks indicating an error during ref resolution\nContext.prototype.cancelAwaits = function () {\n    invariant(this.isRoot);\n    var self = this;\n    Object.keys(this.pendingRefs).forEach(function (uuid) {\n        self.pendingRefs[uuid].forEach(function (refOpts) {\n            self.pendingRefsCount--;\n            refOpts.callback(new Error(\"Reference resolution canceled for \" + uuid));\n        });\n    });\n    this.pendingRefs = {};\n    this.pendingRefsCount = 0;\n};\n\nfunction getTargetContext(target) {\n    return rootContextCache.get(target)\n}\n\n/*\n * Deserialization\n */\n\nfunction schemaHasAlias(schema, name) {\n    for (var key in schema.props)\n        if (typeof schema.props[key] === \"object\" && schema.props[key].jsonname === name)\n            return true\n    return false\n}\n\nfunction deserializeStarProps(context, schema, propDef, obj, json) {\n    checkStarSchemaInvariant(propDef);\n    for (var key in json) if (!(key in schema.props) && !schemaHasAlias(schema, key)) {\n        var jsonValue = json[key];\n        if (propDef === true) {\n            // when deserializing we don't want to silently ignore 'unparseable data' to avoid\n            // confusing bugs\n            invariant(isPrimitive(jsonValue),\n                \"encountered non primitive value while deserializing '*' properties in property '\" +\n                key + \"': \" + jsonValue);\n            obj[key] = jsonValue;\n        } else if (propDef.pattern.test(key)) {\n            if (propDef.factory) {\n                var resultValue = deserializeObjectWithSchema(context, propDef, jsonValue, context.callback || GUARDED_NOOP, {});\n                // deserializeObjectWithSchema returns undefined on error\n                if (resultValue !== undefined) {\n                    obj[key] = resultValue;\n                }\n            } else {\n                function setValue(resultValue) {\n                    if (resultValue !== SKIP) {\n                        obj[key] = resultValue;\n                    }\n                }\n                propDef.deserializer(jsonValue,\n                    // for individual props, use root context based callbacks\n                    // this allows props to complete after completing the object itself\n                    // enabling reference resolving and such\n                    context.rootContext.createCallback(setValue),\n                    context);\n            }\n        }\n    }\n}\n\n/**\n * Deserializes a json structure into an object graph.\n *\n * This process might be asynchronous (for example if there are references with an asynchronous\n * lookup function). The function returns an object (or array of objects), but the returned object\n * might be incomplete until the callback has fired as well (which might happen immediately)\n *\n * @param {object|array} schema to use for deserialization\n * @param {json} json data to deserialize\n * @param {function} callback node style callback that is invoked once the deserialization has\n *   finished. First argument is the optional error, second argument is the deserialized object\n *   (same as the return value)\n * @param {*} customArgs custom arguments that are available as `context.args` during the\n *   deserialization process. This can be used as dependency injection mechanism to pass in, for\n *   example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nfunction deserialize(schema, json, callback, customArgs) {\n    invariant(arguments.length >= 2, \"deserialize expects at least 2 arguments\");\n    schema = getDefaultModelSchema(schema);\n    invariant(isModelSchema(schema), \"first argument should be model schema\");\n    if (Array.isArray(json)) {\n        var items = [];\n        parallel(\n            json,\n            function (childJson, itemDone) {\n                var instance = deserializeObjectWithSchema(null, schema, childJson, itemDone, customArgs);\n                // instance is created synchronously so can be pushed\n                items.push(instance);\n            },\n            callback || GUARDED_NOOP\n        );\n        return items\n    } else\n        return deserializeObjectWithSchema(null, schema, json, callback, customArgs)\n}\n\nfunction deserializeObjectWithSchema(parentContext, modelSchema, json, callback, customArgs) {\n    if (json === null || json === undefined || typeof json !== \"object\")\n        return void callback(null, null)\n    var context = new Context(parentContext, modelSchema, json, callback, customArgs);\n    var target = modelSchema.factory(context);\n    // todo async invariant\n    invariant(!!target, \"No object returned from factory\");\n    // TODO: make invariant?            invariant(schema.extends ||\n    // !target.constructor.prototype.constructor.serializeInfo, \"object has a serializable\n    // supertype, but modelschema did not provide extends clause\")\n    context.setTarget(target);\n    var lock = context.createCallback(GUARDED_NOOP);\n    deserializePropsWithSchema(context, modelSchema, json, target);\n    lock();\n    return target\n}\n\nfunction deserializePropsWithSchema(context, modelSchema, json, target) {\n    if (modelSchema.extends)\n        deserializePropsWithSchema(context, modelSchema.extends, json, target);\n\n    function deserializeProp(propDef, jsonValue, propName) {\n\n        function setValue(value) {\n            if (value !== SKIP) {\n                target[propName] = value;\n            }\n        }\n\n        function preProcess(resultCallback) {\n            return function (err, newValue) {\n                function finalCallback(errPreliminary, finalOrRetryValue) {\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\n                        typeof propDef.afterDeserialize === \"function\") {\n\n                        propDef.deserializer(\n                            finalOrRetryValue,\n                            preProcess(resultCallback),\n                            context,\n                            target[propName]\n                        );\n                    } else {\n                        resultCallback(errPreliminary, finalOrRetryValue);\n                    }\n                }\n\n                onAfterDeserialize(finalCallback, err, newValue, jsonValue, json,\n                    propName, context, propDef);\n            }\n        }\n\n        propDef.deserializer(\n            jsonValue,\n            // for individual props, use root context based callbacks\n            // this allows props to complete after completing the object itself\n            // enabling reference resolving and such\n            preProcess(context.rootContext.createCallback(setValue)),\n            context,\n            target[propName] // initial value\n        );\n    }\n\n    Object.keys(modelSchema.props).forEach(function (propName) {\n        var propDef = modelSchema.props[propName];\n\n        function callbackDeserialize(err, jsonValue) {\n            if (!err && jsonValue !== undefined) {\n                deserializeProp(propDef, jsonValue, propName);\n            }\n        }\n        if (propName === \"*\") {\n            deserializeStarProps(context, modelSchema, propDef, target, json);\n            return\n        }\n        if (propDef === true)\n            propDef = _defaultPrimitiveProp;\n        if (propDef === false)\n            return\n        var jsonAttr = propDef.jsonname || propName;\n        var jsonValue = json[jsonAttr];\n        onBeforeDeserialize(callbackDeserialize, jsonValue, json, jsonAttr, context, propDef);\n    });\n}\n\n\nfunction onBeforeDeserialize(\n    callback, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n\n    if (propDef && typeof propDef.beforeDeserialize === \"function\") {\n        propDef.beforeDeserialize(callback, jsonValue, jsonParentValue, propNameOrIndex, context,\n            propDef);\n    } else {\n        callback(null, jsonValue);\n    }\n}\n\nfunction onAfterDeserialize(\n    callback, err, newValue, jsonValue, jsonParentValue, propNameOrIndex, context, propDef) {\n\n    if (propDef && typeof propDef.afterDeserialize === \"function\") {\n        propDef.afterDeserialize(callback, err, newValue, jsonValue, jsonParentValue,\n            propNameOrIndex, context, propDef);\n    } else {\n        callback(err, newValue);\n    }\n}\n\n/**\n * `object` indicates that this property contains an object that needs to be (de)serialized\n * using its own model schema.\n *\n * N.B. mind issues with circular dependencies when importing model schema's from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class SubTask {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: object(SubTask),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: {\n *         title: 'Sub task',\n *     },\n * });\n *\n * @param {ModelSchema} modelSchema to be used to (de)serialize the object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nfunction object(modelSchema, additionalArgs) {\n    invariant(typeof modelSchema === \"object\" || typeof modelSchema === \"function\", \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\");\n    var result = {\n        serializer: function (item) {\n            modelSchema = getDefaultModelSchema(modelSchema);\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema);\n            if (item === null || item === undefined)\n                return item\n            return serialize(modelSchema, item)\n        },\n        deserializer: function (childJson, done, context) {\n            modelSchema = getDefaultModelSchema(modelSchema);\n            invariant(isModelSchema(modelSchema), \"expected modelSchema, got \" + modelSchema);\n            if (childJson === null || childJson === undefined)\n                return void done(null, childJson)\n            return void deserializeObjectWithSchema(context, modelSchema, childJson, done, additionalArgs)\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/**\n * The `serializeAll` decorator can may used on a class to signal that all primitive properties,\n * or complex properties with a name matching a `pattern`, should be serialized automatically.\n *\n * @example\n * @serializeAll class Store {\n *     a = 3;\n *     b;\n * }\n *\n * const store = new Store();\n * store.c = 5;\n * store.d = {};\n * t.deepEqual(serialize(store), { c: 5 });\n *\n * @example\n * class DataType {\n *     @serializable\n *     x;\n *     @serializable\n *     y;\n * }\n * @serializeAll(/^[a-z]$/, DataType) class ComplexStore {\n * }\n *\n * const store = new ComplexStore();\n * store.a = {x: 1, y: 2};\n * store.b = {};\n * store.somethingElse = 5;\n * t.deepEqual(serialize(store), { a: {x: 1, y: 2}, b: { x: undefined, y: undefined } });\n */\nfunction serializeAll(targetOrPattern, clazzOrSchema) {\n    let propSchema;\n    let invokeImmediately = false;\n    if (arguments.length === 1) {\n        invariant(typeof targetOrPattern === \"function\", \"@serializeAll can only be used as class decorator\");\n        propSchema = true;\n        invokeImmediately = true;\n    }\n    else {\n        invariant(typeof targetOrPattern === \"object\" && targetOrPattern.test, \"@serializeAll pattern doesn't have test\");\n        if (typeof clazzOrSchema === \"function\") {\n            clazzOrSchema = object(clazzOrSchema);\n        }\n        invariant(typeof clazzOrSchema === \"object\" && clazzOrSchema.serializer, \"couldn't resolve schema\");\n        propSchema = Object.assign({}, clazzOrSchema, {pattern: targetOrPattern});\n    }\n    function result(target) {\n        var info = getDefaultModelSchema(target);\n        if (!info || !target.hasOwnProperty(\"serializeInfo\")) {\n            info = createModelSchema(target, {});\n            setDefaultModelSchema(target, info);\n        }\n        getDefaultModelSchema(target).props[\"*\"] = propSchema;\n        return target;\n    }\n    if (invokeImmediately) {\n        return result(targetOrPattern);\n    }\n    return result;\n}\n\n/*\n * Deserialization\n */\n\n\n/**\n * Cancels an asynchronous deserialization or update operation for the specified target object.\n * @param instance object that was previously returned from deserialize or update method\n */\nfunction cancelDeserialize(instance) {\n    invariant(typeof instance === \"object\" && instance && !Array.isArray(instance), \"cancelDeserialize needs an object\");\n    var context = getTargetContext(instance);\n    if (context) {\n        context.cancelAwaits();\n    }\n}\n\n/*\n * Update\n */\n\n/**\n * Similar to deserialize, but updates an existing object instance.\n * Properties will always updated entirely, but properties not present in the json will be kept as is.\n * Further this method behaves similar to deserialize.\n *\n * @param {object} modelSchema, optional if it can be inferred from the instance type\n * @param {object} target target instance to update\n * @param {object} json the json to deserialize\n * @param {function} callback the callback to invoke once deserialization has completed.\n * @param {*} customArgs custom arguments that are available as `context.args` during the deserialization process. This can be used as dependency injection mechanism to pass in, for example, stores.\n * @returns {object|array} deserialized object, possibly incomplete.\n */\nfunction update(modelSchema, target, json, callback, customArgs) {\n    var inferModelSchema =\n        arguments.length === 2 // only target and json\n        || typeof arguments[2] === \"function\"; // callback as third arg\n\n    if (inferModelSchema) {\n        target = arguments[0];\n        modelSchema = getDefaultModelSchema(target);\n        json = arguments[1];\n        callback = arguments[2];\n        customArgs = arguments[3];\n    } else {\n        modelSchema = getDefaultModelSchema(modelSchema);\n    }\n    invariant(isModelSchema(modelSchema), \"update failed to determine schema\");\n    invariant(typeof target === \"object\" && target && !Array.isArray(target), \"update needs an object\");\n    var context = new Context(null, modelSchema, json, callback, customArgs);\n    context.setTarget(target);\n    var lock = context.createCallback(GUARDED_NOOP);\n    var result = deserializePropsWithSchema(context, modelSchema, json, target);\n    lock();\n    return result\n}\n\nfunction defaultRegisterFunction(id, value, context) {\n    context.rootContext.resolve(context.modelSchema, id, context.target);\n}\n\n/**\n *\n *\n * Similar to primitive, but this field will be marked as the identifier for the given Model type.\n * This is used by for example `reference()` to serialize the reference\n *\n * Identifier accepts an optional `registerFn` with the signature:\n * `(id, target, context) => void`\n * that can be used to register this object in some store. note that not all fields of this object might\n * have been deserialized yet.\n *\n * @example\n * var todos = {};\n *\n * var s = _.createSimpleSchema({\n *     id: _.identifier((id, object) => (todos[id] = object)),\n *     title: true,\n * });\n *\n * _.deserialize(s, {\n *     id: 1,\n *     title: 'test0',\n * });\n * _.deserialize(s, [{ id: 2, title: 'test2' }, { id: 1, title: 'test1' }]);\n *\n * t.deepEqual(todos, {\n *     1: { id: 1, title: 'test1' },\n *     2: { id: 2, title: 'test2' },\n * });\n *\n * @param { RegisterFunction | AdditionalPropArgs } arg1 optional registerFn: function to register this object during creation.\n * @param {AdditionalPropArgs} arg2 optional object that contains beforeDeserialize and/or afterDeserialize handlers\n *\n * @returns {PropSchema}\n */\nfunction identifier(arg1, arg2) {\n    var registerFn, additionalArgs;\n    if (typeof arg1 === \"function\") {\n        registerFn = arg1;\n        additionalArgs = arg2;\n    } else {\n        additionalArgs = arg1;\n    }\n    invariant(!additionalArgs || typeof additionalArgs === \"object\", \"Additional property arguments should be an object, register function should be omitted or a funtion\");\n    var result = {\n        identifier: true,\n        serializer: _defaultPrimitiveProp.serializer,\n        deserializer: function (jsonValue, done, context) {\n            _defaultPrimitiveProp.deserializer(jsonValue, function(err, id) {\n                defaultRegisterFunction(id, context.target, context);\n                if (registerFn)\n                    registerFn(id, context.target, context);\n                done(err, id);\n            });\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/**\n * Similar to primitive, serializes instances of Date objects\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nfunction date(additionalArgs) {\n    // TODO: add format option?\n    var result = {\n        serializer: function(value) {\n            if (value === null || value === undefined)\n                return value\n            invariant(value instanceof Date, \"Expected Date object\");\n            return value.getTime()\n        },\n        deserializer: function (jsonValue, done) {\n            if (jsonValue === null || jsonValue === undefined)\n                return void done(null, jsonValue)\n            return void done(null, new Date(jsonValue))\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/**\n * Alias indicates that this model property should be named differently in the generated json.\n * Alias should be the outermost propschema.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: alias('task', primitive()),\n * });\n *\n * console.dir(serialize(new Todo('test')));\n * // { task : \"test\" }\n *\n * @param {string} name name of the json field to be used for this property\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\nfunction alias(name, propSchema) {\n    invariant(name && typeof name === \"string\", \"expected prop name as first argument\");\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema;\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\");\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is already aliased\");\n    return {\n        jsonname: name,\n        serializer: propSchema.serializer,\n        deserializer: propSchema.deserializer,\n        identifier: isIdentifierPropSchema(propSchema),\n        beforeDeserialize: propSchema.beforeDeserialize,\n        afterDeserialize: propSchema.afterDeserialize\n    }\n}\n\n/**\n * Can be used to create simple custom propSchema. Multiple things can be done inside of a custom propSchema, like deserializing and serializing other (polymorphic) objects, skipping the serialization of something or checking the context of the obj being (de)serialized.\n\n * The `custom` function takes two parameters, the `serializer` function and the `deserializer` function.\n\n * The `serializer` function has the signature:\n * `(value, key, obj) => void`\n\n * When serializing the object `{a: 1}` the `serializer` function will be called with `serializer(1, 'a', {a: 1})`.\n\n * The `deserializer` function has the following signature for synchronous processing\n * `(value, context, oldValue) => void`\n\n * For asynchronous processing the function expects the following signature\n * `(value, context, oldValue, callback) => void`\n\n * When deserializing the object `{b: 2}` the `deserializer` function will be called with `deserializer(2, contextObj)` ([contextObj reference](https://github.com/mobxjs/serializr#deserialization-context)).\n *\n * @example\n * var schemaDefault = _.createSimpleSchema({\n *     a: _.custom(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v) {\n *             return v - 2;\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaDefault, { a: 4 }), { a: 6 });\n * t.deepEqual(_.deserialize(schemaDefault, { a: 6 }), { a: 4 });\n *\n * var schemaWithAsyncProps = _.createSimpleSchema({\n *     a: _.customAsync(\n *         function(v) {\n *             return v + 2;\n *         },\n *         function(v, context, oldValue, callback) {\n *             somePromise(v, context, oldValue).then((result) => {\n *                 callback(null, result - 2)\n *             }.catch((err) => {\n *                 callback(err)\n *             }\n *         }\n *     ),\n * });\n * t.deepEqual(_.serialize(schemaWithAsyncProps, { a: 4 }), { a: 6 });\n * _.deserialize(schemaWithAsyncProps, { a: 6 }, (err, res) => {\n *   t.deepEqual(res.a, 4)\n * };\n\n *\n * @param {function} serializer function that takes a model value and turns it into a json value\n * @param {function} deserializer function that takes a json value and turns it into a model value. It also takes context argument, which can allow you to deserialize based on the context of other parameters.\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nfunction custom(serializer, deserializer, additionalArgs) {\n    invariant(typeof serializer === \"function\", \"first argument should be function\");\n    invariant((typeof deserializer === \"function\"), \"second argument should be a function or promise\");\n    var result = {\n        serializer: serializer,\n        deserializer: function (jsonValue, done, context, oldValue) {\n            if (deserializer.length === 4) {\n                deserializer(jsonValue, context, oldValue, done, additionalArgs);\n            } else {\n                done(null, deserializer(jsonValue, context, oldValue, null, additionalArgs));\n            }\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/**\n * Optional indicates that this model property shouldn't be serialized if it isn't present.\n *\n * @example\n * createModelSchema(Todo, {\n *     title: optional(primitive()),\n * });\n *\n * console.dir(serialize(new Todo()));\n * // {}\n *\n * @param {PropSchema} propSchema propSchema to (de)serialize the contents of this field\n * @returns {PropSchema}\n */\nfunction optional(name, propSchema) {\n    propSchema = (!propSchema || propSchema === true)  ? _defaultPrimitiveProp : propSchema;\n    invariant(isPropSchema(propSchema), \"expected prop schema as second argument\");\n    const propSerializer = propSchema.serializer;\n    invariant(typeof propSerializer === \"function\", \"expected prop schema to have a callable serializer\");\n    function serializer(...args) {\n        const result = propSerializer(...args);\n        if (result === undefined) {\n            return SKIP\n        }\n        return result\n    }\n    return Object.assign({}, propSchema, {serializer})\n}\n\nfunction createDefaultRefLookup(modelSchema) {\n    return function resolve(uuid, cb, context) {\n        context.rootContext.await(modelSchema, uuid, cb);\n    }\n}\n\n/**\n * `reference` can be used to (de)serialize references that point to other models.\n *\n * The first parameter should be either a ModelSchema that has an `identifier()` property (see identifier)\n * or a string that represents which attribute in the target object represents the identifier of the object.\n *\n * The second parameter is a lookup function that is invoked during deserialization to resolve an identifier to\n * an object. Its signature should be as follows:\n *\n * `lookupFunction(identifier, callback, context)` where:\n * 1. `identifier` is the identifier being resolved\n * 2. `callback` is a node style calblack function to be invoked with the found object (as second arg) or an error (first arg)\n * 3. `context` see context.\n *\n * The lookupFunction is optional. If it is not provided, it will try to find an object of the expected type and required identifier within the same JSON document\n *\n * N.B. mind issues with circular dependencies when importing model schemas from other files! The module resolve algorithm might expose classes before `createModelSchema` is executed for the target class.\n *\n * @example\n * class User {}\n * class Post {}\n *\n * createModelSchema(User, {\n *     uuid: identifier(),\n *     displayname: primitive(),\n * });\n *\n * createModelSchema(Post, {\n *     author: reference(User, findUserById),\n *     message: primitive(),\n * });\n *\n * function findUserById(uuid, callback) {\n *     fetch('http://host/user/' + uuid)\n *         .then(userData => {\n *             deserialize(User, userData, callback);\n *         })\n *         .catch(callback);\n * }\n *\n * deserialize(\n *     Post,\n *     {\n *         message: 'Hello World',\n *         author: 234,\n *     },\n *     (err, post) => {\n *         console.log(post);\n *     }\n * );\n *\n * @param target: ModelSchema or string\n * @param {RefLookupFunction | AdditionalPropArgs} lookupFn optional function or additionalArgs object\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nfunction reference(target, lookupFn, additionalArgs) {\n    invariant(!!target, \"No modelschema provided. If you are importing it from another file be aware of circular dependencies.\");\n    var initialized = false;\n    var childIdentifierAttribute;\n    if (typeof lookupFn === \"object\" && additionalArgs === undefined) {\n        additionalArgs = lookupFn;\n        lookupFn = undefined;\n    }\n    function initialize() {\n        initialized = true;\n        invariant(typeof target !== \"string\" || lookupFn && typeof lookupFn === \"function\", \"if the reference target is specified by attribute name, a lookup function is required\");\n        invariant(!lookupFn || typeof lookupFn === \"function\", \"second argument should be a lookup function or additional arguments object\");\n        if (typeof target === \"string\")\n            childIdentifierAttribute = target;\n        else {\n            var modelSchema = getDefaultModelSchema(target);\n            invariant(isModelSchema(modelSchema), \"expected model schema or string as first argument for 'ref', got \" + modelSchema);\n            lookupFn = lookupFn || createDefaultRefLookup(modelSchema);\n            childIdentifierAttribute = getIdentifierProp(modelSchema);\n            invariant(!!childIdentifierAttribute, \"provided model schema doesn't define an identifier() property and cannot be used by 'ref'.\");\n        }\n    }\n    var result = {\n        serializer: function (item) {\n            if (!initialized)\n                initialize();\n            return item ? item[childIdentifierAttribute] : null\n        },\n        deserializer: function(identifierValue, done, context) {\n            if (!initialized)\n                initialize();\n            if (identifierValue === null || identifierValue === undefined)\n                done(null, identifierValue);\n            else\n                lookupFn(identifierValue, done, context);\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/**\n * List indicates that this property contains a list of things.\n * Accepts a sub model schema to serialize the contents\n *\n * @example\n * class SubTask {}\n * class Task {}\n * class Todo {}\n *\n * createModelSchema(SubTask, {\n *     title: true,\n * });\n * createModelSchema(Todo, {\n *     title: true,\n *     subTask: list(object(SubTask)),\n * });\n *\n * const todo = deserialize(Todo, {\n *     title: 'Task',\n *     subTask: [\n *         {\n *             title: 'Sub task 1',\n *         },\n *     ],\n * });\n *\n * @param {PropSchema} propSchema to be used to (de)serialize the contents of the array\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nfunction list(propSchema, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp;\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n    invariant(!isAliasedPropSchema(propSchema),\n        \"provided prop is aliased, please put aliases first\");\n    var result = {\n        serializer: function (ar) {\n            if (ar === undefined) {\n                return SKIP\n            }\n            invariant(ar && \"length\" in ar && \"map\" in ar, \"expected array (like) object\");\n            return ar.map(propSchema.serializer)\n        },\n        deserializer: function (jsonArray, done, context) {\n            if (!Array.isArray(jsonArray))\n                return void done(\"[serializr] expected JSON array\")\n\n            function processItem(jsonValue, onItemDone, itemIndex) {\n                function callbackBefore(err, value) {\n                    if (!err) {\n                        propSchema.deserializer(value, deserializeDone, context);\n                    } else {\n                        onItemDone(err);\n                    }\n                }\n\n                function deserializeDone(err, value) {\n                    if (typeof propSchema.afterDeserialize === \"function\") {\n                        onAfterDeserialize(callbackAfter, err, value, jsonValue, itemIndex, context,\n                            propSchema);\n                    } else {\n                        onItemDone(err, value);\n                    }\n                }\n\n                function callbackAfter(errPreliminary, finalOrRetryValue) {\n                    if (errPreliminary && finalOrRetryValue !== undefined &&\n                        typeof propSchema.afterDeserialize === \"function\") {\n\n                        propSchema.deserializer(\n                            finalOrRetryValue,\n                            deserializeDone,\n                            context\n                        );\n                    } else {\n                        onItemDone(errPreliminary, finalOrRetryValue);\n                    }\n                }\n\n                onBeforeDeserialize(callbackBefore, jsonValue, jsonArray, itemIndex, context,\n                    propSchema);\n            }\n\n            parallel(\n                jsonArray,\n                processItem,\n                done\n            );\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/**\n * Similar to list, but map represents a string keyed dynamic collection.\n * This can be both plain objects (default) or ES6 Map like structures.\n * This will be inferred from the initial value of the targetted attribute.\n *\n * @param {*} propSchema\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nfunction map(propSchema, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp;\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n    invariant(!isAliasedPropSchema(propSchema), \"provided prop is aliased, please put aliases first\");\n    var res = {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\");\n            var isMap = isMapLike(m);\n            var result = {};\n            if (isMap)\n                m.forEach(function (value, key) {\n                    result[key] = propSchema.serializer(value);\n                });\n            else for (var key in m)\n                result[key] = propSchema.serializer(m[key]);\n            return result\n        },\n        deserializer: function (jsonObject, done, context, oldValue) {\n            if (!jsonObject || typeof jsonObject !== \"object\")\n                return void done(\"[serializr] expected JSON object\")\n            var keys = Object.keys(jsonObject);\n            list(propSchema, additionalArgs).deserializer(\n                keys.map(function (key) {\n                    return jsonObject[key]\n                }),\n                function (err, values) {\n                    if (err)\n                        return void done(err)\n                    var isMap = isMapLike(oldValue);\n                    var newValue;\n                    if (isMap) {\n                        // if the oldValue is a map, we recycle it\n                        // there are many variations and this way we don't have to\n                        // know about the original constructor\n                        oldValue.clear();\n                        newValue = oldValue;\n                    } else\n                        newValue = {};\n                    for (var i = 0, l = keys.length; i < l; i++)\n                        if (isMap)\n                            newValue.set(keys[i], values[i]);\n                        else\n                            newValue[keys[i]] = values[i];\n                    done(null, newValue);\n                },\n                context\n            );\n        }\n    };\n    res = processAdditionalPropArgs(res, additionalArgs);\n    return res\n}\n\n/**\n * Similar to map, mapAsArray can be used to serialize a map-like collection where the key is\n * contained in the 'value object'. Example: consider Map<id: number, customer: Customer> where the\n * Customer object has the id stored on itself. mapAsArray stores all values from the map into an\n * array which is serialized. Deserialization returns a ES6 Map or plain object object where the\n * `keyPropertyName` of each object is used for keys. For ES6 maps this has the benefit of being\n * allowed to have non-string keys in the map. The serialized json also may be slightly more\n * compact.\n *\n * @param {any} propSchema\n * @param {string} keyPropertyName - the property of stored objects used as key in the map\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {PropSchema}\n */\nfunction mapAsArray(propSchema, keyPropertyName, additionalArgs) {\n    propSchema = propSchema || _defaultPrimitiveProp;\n    invariant(isPropSchema(propSchema), \"expected prop schema as first argument\");\n    invariant(!!keyPropertyName, \"expected key property name as second argument\");\n    var res = {\n        serializer: function (m) {\n            invariant(m && typeof m === \"object\", \"expected object or Map\");\n            var isMap = isMapLike(m);\n            var result = [];\n            // eslint-disable-next-line no-unused-vars\n            if (isMap) {\n                m.forEach(function (value) {\n                    result.push(propSchema.serializer(value));\n                });\n            } else for (var key in m) {\n                result.push(propSchema.serializer(m[key]));\n                // result[key] = propSchema.serializer(m[key])\n            }\n            return result\n        },\n        deserializer: function (jsonArray, done, context, oldValue) {\n            list(propSchema, additionalArgs).deserializer(\n                jsonArray,\n                function (err, values) {\n                    if (err)\n                        return void done(err)\n                    var isMap = isMapLike(oldValue);\n                    var newValue;\n                    if (isMap) {\n                        oldValue.clear();\n                        newValue = oldValue;\n                    } else {\n                        newValue = {};\n                    }\n                    for (var i = 0, l = jsonArray.length; i < l; i++)\n                        if (isMap)\n                            newValue.set(values[i][keyPropertyName], values[i]);\n                        else\n                            newValue[values[i][keyPropertyName].toString()] = values[i];\n                    done(null, newValue);\n                },\n                context\n            );\n        }\n    };\n    res = processAdditionalPropArgs(res, additionalArgs);\n    return res\n}\n\n/**\n * Indicates that this field is only need to putted in the serialized json or\n * deserialized instance, without any transformations. Stay with its original value\n *\n * @example\n * createModelSchema(Model, {\n *     rawData: raw(),\n * });\n *\n * console.dir(serialize(new Model({ rawData: { a: 1, b: [], c: {} } } })));\n * // outputs: { rawData: { a: 1, b: [], c: {} } } }\n *\n * @param {AdditionalPropArgs} additionalArgs optional object that contains beforeDeserialize and/or afterDeserialize handlers\n * @returns {ModelSchema}\n */\nfunction raw(additionalArgs) {\n    var result = {\n        serializer: function (value) {\n            return value\n        },\n        deserializer: function (jsonValue, done) {\n            return void done(null, jsonValue)\n        }\n    };\n    result = processAdditionalPropArgs(result, additionalArgs);\n    return result\n}\n\n/*\n * ## Managing model schemas\n */\n// ~ deprecated\n\nexport { createSimpleSchema, createModelSchema, getDefaultModelSchema, setDefaultModelSchema, serializable, serialize, serializeAll, cancelDeserialize, deserialize, update, primitive, identifier, date, alias, custom, object, object as child, optional, reference, reference as ref, list, map, mapAsArray, raw, SKIP };\n"]},"metadata":{},"sourceType":"module"}